#version 460 core
#extension GL_EXT_ray_query : enable

#include<..\..\..\resources\shaders\include\Transformations.glsl>

layout(local_size_x = 8, local_size_y = 8) in;

layout(set = 0, binding = 0) uniform accelerationStructureEXT tlas;
layout(set = 1, binding = 0) uniform sampler2D ipImage;
layout(set = 1, binding = 1) uniform writeonly image2D opImage;

layout(push_constant) uniform invVPMat {
	mat4 invVMat;
	mat4 invPMat;
};

void main(void) {
	float depth = texelFetch(ipImage, ivec2(gl_GlobalInvocationID.xy), 0).r;
	vec2 uv = ivec2(gl_GlobalInvocationID.xy) / vec2(imageSize(opImage));
    vec3 ndc = vec3(uv * 2.0 - 1.0, depth);
    //vec3 fragPos = PerspectiveTransform(ndc, invMat);

	const vec2 pixelCenter = vec2(gl_GlobalInvocationID.xy) + vec2(0.5);
    const vec2 inUV = pixelCenter/vec2(imageSize(opImage));
    vec2 d = inUV * 2.0 - 1.0;
	
	vec3 lightPos = vec3(-4.0f, 3.90f, 0.0f);

	vec4 origin    = invVMat * vec4(0, 0, 0, 1);
	vec4 target    = invPMat * vec4(d.x, d.y, 1, 1);
	vec4 direction = invVMat * vec4(normalize(target.xyz), 0);
	//float m = length(dir);
	//dir = normalize(dir);

	rayQueryEXT query;
	rayQueryInitializeEXT(query, tlas, gl_RayFlagsNoneEXT, 0xff, origin.xyz, 0.01, direction.xyz, 1e6);
	rayQueryProceedEXT(query);
	float dist = 1.0;
	if (rayQueryGetIntersectionTypeEXT(query, true) == gl_RayQueryCommittedIntersectionTriangleEXT)
	{
		dist = 0.0;
	}

	imageStore(opImage, ivec2(gl_GlobalInvocationID.xy), vec4(dist, 1.0, 0.0, 1.0));
}